{{>partial_header}}

use serde::{Serialize, Deserialize};
use typed_builder::TypedBuilder;

{{#withAWSV4Signature}}
use std::time::SystemTime;
use aws_sigv4::http_request::{sign, SigningSettings, SigningParams, SignableRequest};
use http;
use secrecy::{SecretString, ExposeSecret};
{{/withAWSV4Signature}}
{{#supportTokenSource}}
use std::sync::Arc;
use google_cloud_token::TokenSource;
use async_trait::async_trait;
{{/supportTokenSource}}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, typed_builder::TypedBuilder)]
pub struct Configuration {
    #[serde(default = "default_base_path")]
    #[builder(default_code = "default_base_path()")]
    pub base_path: String,
    #[serde(default = "default_user_agent")]
    #[builder(default_code = "default_user_agent()")]
    pub user_agent: Option<String>,
    #[serde(skip_serializing, skip_deserializing)]
    #[builder(default_code = "default_client()")]
    pub client: {{#supportMiddleware}}reqwest_middleware::ClientWithMiddleware{{/supportMiddleware}}{{^supportMiddleware}}reqwest{{^supportAsync}}::blocking{{/supportAsync}}::Client{{/supportMiddleware}},
    {{^supportTokenSource}}
    #[serde(default)]
    #[builder(default)]
    pub basic_auth: Option<BasicAuth>,
    #[serde(default)]
    #[builder(default)]
    pub oauth_access_token: Option<String>,
    #[serde(default)]
    #[builder(default)]
    pub bearer_access_token: Option<String>,
    #[serde(default)]
    #[builder(default)]
    pub api_key: Option<ApiKey>,
    {{/supportTokenSource}}
    {{#withAWSV4Signature}}
    #[serde(default)]
    #[builder(default)]
    pub aws_v4_key: Option<AWSv4Key>,
    {{/withAWSV4Signature}}
    {{#supportAsync}}
    {{#supportTokenSource}}
    #[serde(skip_serializing, skip_deserializing)]
    #[builder(default_code = "default_token_source()")]
    pub token_source: Arc<dyn TokenSource>,
    {{/supportTokenSource}}
    {{/supportAsync}}
}
{{^supportTokenSource}}

pub type BasicAuth = (String, Option<String>);

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, typed_builder::TypedBuilder)]
pub struct ApiKey {
    #[serde(default)]
    #[builder(default)]
    pub prefix: Option<String>,
    pub key: String,
}
{{/supportTokenSource}}

{{#withAWSV4Signature}}
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, typed_builder::TypedBuilder)]
pub struct AWSv4Key {
    pub access_key: String,
    #[serde(skip_serializing, skip_deserializing)]
    #[builder(setter(into))]
    pub secret_key: SecretString,
    pub region: String,
    pub service: String,
}

impl AWSv4Key {
    pub fn sign(&self, uri: &str, method: &str, body: &str) -> Result<Vec::<(String, String)>, aws_sigv4::http_request::Error> {
	let request = http::Request::builder()
	    .uri(uri)
	    .method(method)
	    .body(body).unwrap();
	let signing_settings = SigningSettings::default();
	let signing_params = SigningParams::builder()
	    .access_key(self.access_key.as_str())
	    .secret_key(self.secret_key.expose_secret().as_str())
	    .region(self.region.as_str())
	    .service_name(self.service.as_str())
	    .time(SystemTime::now())
	    .settings(signing_settings)
	    .build()
	    .unwrap();
	let signable_request = SignableRequest::from(&request);
	let (mut signing_instructions, _signature) = sign(signable_request, &signing_params)?.into_parts();
	let mut additional_headers = Vec::<(String, String)>::new();
	if let Some(new_headers) = signing_instructions.take_headers() {
            for (name, value) in new_headers.into_iter() {
		additional_headers.push((name.expect("header should have name").to_string(),
		                         value.to_str().expect("header value should be a string").to_string()));
            }
        }
	Ok(additional_headers)
    }
}
{{/withAWSV4Signature}}

fn default_base_path() -> String {
    "{{{basePath}}}:8444".to_owned()
}

fn default_user_agent() -> Option<String> {
    Some(format!("{}-rust/{}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION")))
}

fn default_client() -> {{#supportMiddleware}}reqwest_middleware::ClientWithMiddleware{{/supportMiddleware}}{{^supportMiddleware}}reqwest{{^supportAsync}}::blocking{{/supportAsync}}::Client{{/supportMiddleware}} {
    {{#supportMiddleware}}reqwest_middleware::ClientBuilder::new(reqwest{{^supportAsync}}::blocking{{/supportAsync}}::Client::new()).build(){{/supportMiddleware}}{{^supportMiddleware}}reqwest{{^supportAsync}}::blocking{{/supportAsync}}::Client::new(){{/supportMiddleware}}
}

{{#supportAsync}}
{{#supportTokenSource}}
fn default_token_source() -> Arc<dyn TokenSource> {
    Arc::new(NoopTokenSource{})
}
{{/supportTokenSource}}
{{/supportAsync}}

impl Configuration {
    pub fn new() -> Configuration {
        Configuration::default()
    }
}

impl Default for Configuration {
    fn default() -> Self {
        Configuration {
            base_path: default_base_path(),
            user_agent: default_user_agent(),
            client: default_client(),
            {{^supportTokenSource}}
            basic_auth: None,
            oauth_access_token: None,
            bearer_access_token: None,
            api_key: None,
            {{/supportTokenSource}}
            {{#withAWSV4Signature}}
            aws_v4_key: None,
            {{/withAWSV4Signature}}
            {{#supportTokenSource}}
            token_source: default_token_source(),
            {{/supportTokenSource}}
        }
    }
}
{{#supportTokenSource}}
#[derive(Debug)]
struct NoopTokenSource{}

#[async_trait]
impl TokenSource for NoopTokenSource {
    async fn token(&self) -> Result<String, Box<dyn std::error::Error + Send + Sync>> {
        panic!("This is dummy token source. You can use TokenSourceProvider from 'google_cloud_auth' crate, or any other compatible crate.")
    }
}
{{/supportTokenSource}}
