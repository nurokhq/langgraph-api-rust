/*
 * LangSmith Deployment
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::models;
use serde::{Deserialize, Serialize};

/// ThreadCronCreate : Payload for creating a thread-specific cron job (runs on the same thread).
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct ThreadCronCreate {
    /// The cron schedule to execute this job on.
    #[serde(rename = "schedule")]
    pub schedule: String,
    /// The end date to stop running the cron.
    #[serde(rename = "end_time", skip_serializing_if = "Option::is_none")]
    pub end_time: Option<String>,
    #[serde(rename = "assistant_id")]
    pub assistant_id: Box<models::ThreadCronCreateAssistantId>,
    #[serde(rename = "input", skip_serializing_if = "Option::is_none")]
    pub input: Option<Box<models::Input2>>,
    /// Metadata to assign to the cron job runs.
    #[serde(rename = "metadata", skip_serializing_if = "Option::is_none")]
    pub metadata: Option<serde_json::Value>,
    #[serde(rename = "config", skip_serializing_if = "Option::is_none")]
    pub config: Option<Box<models::Config3>>,
    /// Static context added to the assistant.
    #[serde(rename = "context", skip_serializing_if = "Option::is_none")]
    pub context: Option<serde_json::Value>,
    /// Webhook to call after LangGraph API call is done.
    #[serde(rename = "webhook", skip_serializing_if = "Option::is_none")]
    pub webhook: Option<String>,
    #[serde(rename = "interrupt_before", skip_serializing_if = "Option::is_none")]
    pub interrupt_before: Option<Box<models::InterruptBefore1>>,
    #[serde(rename = "interrupt_after", skip_serializing_if = "Option::is_none")]
    pub interrupt_after: Option<Box<models::InterruptAfter1>>,
    /// Multitask strategy to use. Must be one of 'reject', 'interrupt', 'rollback', or 'enqueue'.
    #[serde(rename = "multitask_strategy", skip_serializing_if = "Option::is_none")]
    pub multitask_strategy: Option<MultitaskStrategy>,
}

impl ThreadCronCreate {
    /// Payload for creating a thread-specific cron job (runs on the same thread).
    pub fn new(
        schedule: String,
        assistant_id: models::ThreadCronCreateAssistantId,
    ) -> ThreadCronCreate {
        ThreadCronCreate {
            schedule,
            end_time: None,
            assistant_id: Box::new(assistant_id),
            input: None,
            metadata: None,
            config: None,
            context: None,
            webhook: None,
            interrupt_before: None,
            interrupt_after: None,
            multitask_strategy: None,
        }
    }
}
/// Multitask strategy to use. Must be one of 'reject', 'interrupt', 'rollback', or 'enqueue'.
#[derive(
    Clone, Copy, Debug, Default, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize,
)]
pub enum MultitaskStrategy {
    #[serde(rename = "reject")]
    #[default]
    Reject,
    #[serde(rename = "rollback")]
    Rollback,
    #[serde(rename = "interrupt")]
    Interrupt,
    #[serde(rename = "enqueue")]
    Enqueue,
}
