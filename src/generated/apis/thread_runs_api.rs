/*
 * LangSmith Deployment
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, UploadFile, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`cancel_run_http_threads_thread_id_runs_run_id_cancel_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelRunHttpThreadsThreadIdRunsRunIdCancelPostError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`cancel_runs_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CancelRunsPostError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_run_threads_thread_id_runs_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateRunThreadsThreadIdRunsPostError {
    Status404(String),
    Status409(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_run_threads_thread_id_runs_run_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteRunThreadsThreadIdRunsRunIdDeleteError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_run_http_threads_thread_id_runs_run_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRunHttpThreadsThreadIdRunsRunIdGetError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`join_run_http_threads_thread_id_runs_run_id_join_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JoinRunHttpThreadsThreadIdRunsRunIdJoinGetError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_runs_http_threads_thread_id_runs_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListRunsHttpThreadsThreadIdRunsGetError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stream_run_http_threads_thread_id_runs_run_id_join_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamRunHttpThreadsThreadIdRunsRunIdJoinGetError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stream_run_threads_thread_id_runs_stream_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StreamRunThreadsThreadIdRunsStreamPostError {
    Status404(String),
    Status409(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`wait_run_threads_thread_id_runs_wait_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum WaitRunThreadsThreadIdRunsWaitPostError {
    Status404(String),
    Status409(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

pub fn cancel_run_http_threads_thread_id_runs_run_id_cancel_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
    wait: Option<bool>,
    action: Option<&str>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_path_run_id = run_id;
    let p_query_wait = wait;
    let p_query_action = action;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/cancel",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id),
        run_id = crate::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_wait {
        req_builder = req_builder.query(&[("wait", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn cancel_run_http_threads_thread_id_runs_run_id_cancel_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
    wait: Option<bool>,
    action: Option<&str>,
) -> Result<serde_json::Value, Error<CancelRunHttpThreadsThreadIdRunsRunIdCancelPostError>> {
    let req_builder = cancel_run_http_threads_thread_id_runs_run_id_cancel_post_request_builder(
        configuration,
        thread_id,
        run_id,
        wait,
        action,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelRunHttpThreadsThreadIdRunsRunIdCancelPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Cancel one or more runs. Can cancel runs by thread ID and run IDs, or by status filter.
pub fn cancel_runs_post_request_builder(
    configuration: &configuration::Configuration,
    runs_cancel: Option<models::RunsCancel>,
    action: Option<&str>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_runs_cancel = runs_cancel;
    let p_query_action = action;

    let uri_str = format!("{}/runs/cancel", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_runs_cancel);

    Ok(req_builder)
}

pub async fn cancel_runs_post(
    configuration: &configuration::Configuration,
    runs_cancel: Option<models::RunsCancel>,
    action: Option<&str>,
) -> Result<(), Error<CancelRunsPostError>> {
    let req_builder = cancel_runs_post_request_builder(configuration, runs_cancel, action)
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CancelRunsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a run in existing thread, return the run ID immediately. Don't wait for the final run output.
pub fn create_run_threads_thread_id_runs_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_create_stateful: models::RunCreateStateful,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_run_create_stateful = run_create_stateful;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_run_create_stateful);

    Ok(req_builder)
}

pub async fn create_run_threads_thread_id_runs_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_create_stateful: models::RunCreateStateful,
) -> Result<models::Run, Error<CreateRunThreadsThreadIdRunsPostError>> {
    let req_builder = create_run_threads_thread_id_runs_post_request_builder(
        configuration,
        thread_id,
        run_create_stateful,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Run`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Run`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateRunThreadsThreadIdRunsPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a run by ID.
pub fn delete_run_threads_thread_id_runs_run_id_delete_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_path_run_id = run_id;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id),
        run_id = crate::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn delete_run_threads_thread_id_runs_run_id_delete(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
) -> Result<serde_json::Value, Error<DeleteRunThreadsThreadIdRunsRunIdDeleteError>> {
    let req_builder = delete_run_threads_thread_id_runs_run_id_delete_request_builder(
        configuration,
        thread_id,
        run_id,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteRunThreadsThreadIdRunsRunIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a run by ID.
pub fn get_run_http_threads_thread_id_runs_run_id_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_path_run_id = run_id;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id),
        run_id = crate::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn get_run_http_threads_thread_id_runs_run_id_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
) -> Result<models::Run, Error<GetRunHttpThreadsThreadIdRunsRunIdGetError>> {
    let req_builder = get_run_http_threads_thread_id_runs_run_id_get_request_builder(
        configuration,
        thread_id,
        run_id,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Run`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Run`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRunHttpThreadsThreadIdRunsRunIdGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Wait for a run to finish.
pub fn join_run_http_threads_thread_id_runs_run_id_join_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
    cancel_on_disconnect: Option<bool>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_path_run_id = run_id;
    let p_query_cancel_on_disconnect = cancel_on_disconnect;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/join",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id),
        run_id = crate::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_cancel_on_disconnect {
        req_builder = req_builder.query(&[("cancel_on_disconnect", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn join_run_http_threads_thread_id_runs_run_id_join_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
    cancel_on_disconnect: Option<bool>,
) -> Result<serde_json::Value, Error<JoinRunHttpThreadsThreadIdRunsRunIdJoinGetError>> {
    let req_builder = join_run_http_threads_thread_id_runs_run_id_join_get_request_builder(
        configuration,
        thread_id,
        run_id,
        cancel_on_disconnect,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<JoinRunHttpThreadsThreadIdRunsRunIdJoinGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// List runs for a thread.
pub fn list_runs_http_threads_thread_id_runs_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
    status: Option<&str>,
    select: Option<Vec<String>>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_query_limit = limit;
    let p_query_offset = offset;
    let p_query_status = status;
    let p_query_select = select;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_status {
        req_builder = req_builder.query(&[("status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_select {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .iter()
                    .map(|p| ("select".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "select",
                &param_value
                    .iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn list_runs_http_threads_thread_id_runs_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    limit: Option<i32>,
    offset: Option<i32>,
    status: Option<&str>,
    select: Option<Vec<String>>,
) -> Result<Vec<models::Run>, Error<ListRunsHttpThreadsThreadIdRunsGetError>> {
    let req_builder = list_runs_http_threads_thread_id_runs_get_request_builder(
        configuration,
        thread_id,
        limit,
        offset,
        status,
        select,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Run&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Run&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListRunsHttpThreadsThreadIdRunsGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Join a run stream. This endpoint streams output in real-time from a run similar to the /threads/__THREAD_ID__/runs/stream endpoint. If the run has been created with `stream_resumable=true`, the stream can be resumed from the last seen event ID.
pub fn stream_run_http_threads_thread_id_runs_run_id_join_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
    last_event_id: Option<&str>,
    stream_mode: Option<&str>,
    cancel_on_disconnect: Option<bool>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_path_run_id = run_id;
    let p_header_last_event_id = last_event_id;
    let p_query_stream_mode = stream_mode;
    let p_query_cancel_on_disconnect = cancel_on_disconnect;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/{run_id}/stream",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id),
        run_id = crate::apis::urlencode(p_path_run_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_stream_mode {
        req_builder = req_builder.query(&[("stream_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_cancel_on_disconnect {
        req_builder = req_builder.query(&[("cancel_on_disconnect", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_last_event_id {
        req_builder = req_builder.header("Last-Event-ID", param_value.to_string());
    }

    Ok(req_builder)
}

pub async fn stream_run_http_threads_thread_id_runs_run_id_join_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_id: &str,
    last_event_id: Option<&str>,
    stream_mode: Option<&str>,
    cancel_on_disconnect: Option<bool>,
) -> Result<String, Error<StreamRunHttpThreadsThreadIdRunsRunIdJoinGetError>> {
    let req_builder = stream_run_http_threads_thread_id_runs_run_id_join_get_request_builder(
        configuration,
        thread_id,
        run_id,
        last_event_id,
        stream_mode,
        cancel_on_disconnect,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `String`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StreamRunHttpThreadsThreadIdRunsRunIdJoinGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a run in existing thread. Stream the output.
pub fn stream_run_threads_thread_id_runs_stream_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_create_stateful: models::RunCreateStateful,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_run_create_stateful = run_create_stateful;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/stream",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_run_create_stateful);

    Ok(req_builder)
}

pub async fn stream_run_threads_thread_id_runs_stream_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_create_stateful: models::RunCreateStateful,
) -> Result<String, Error<StreamRunThreadsThreadIdRunsStreamPostError>> {
    let req_builder = stream_run_threads_thread_id_runs_stream_post_request_builder(
        configuration,
        thread_id,
        run_create_stateful,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `String`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StreamRunThreadsThreadIdRunsStreamPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a run in existing thread. Wait for the final output and then return it.
pub fn wait_run_threads_thread_id_runs_wait_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_create_stateful: models::RunCreateStateful,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_run_create_stateful = run_create_stateful;

    let uri_str = format!(
        "{}/threads/{thread_id}/runs/wait",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_run_create_stateful);

    Ok(req_builder)
}

pub async fn wait_run_threads_thread_id_runs_wait_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
    run_create_stateful: models::RunCreateStateful,
) -> Result<serde_json::Value, Error<WaitRunThreadsThreadIdRunsWaitPostError>> {
    let req_builder = wait_run_threads_thread_id_runs_wait_post_request_builder(
        configuration,
        thread_id,
        run_create_stateful,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<WaitRunThreadsThreadIdRunsWaitPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
