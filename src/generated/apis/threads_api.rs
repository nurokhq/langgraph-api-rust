/*
 * LangSmith Deployment
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{ContentType, Error, UploadFile, configuration};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};

/// struct for typed errors of method [`copy_thread_post_threads_thread_id_copy_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CopyThreadPostThreadsThreadIdCopyPostError {
    Status409(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`count_threads_threads_count_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CountThreadsThreadsCountPostError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_thread_threads_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateThreadThreadsPostError {
    Status409(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_thread_threads_thread_id_delete`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteThreadThreadsThreadIdDeleteError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_latest_thread_state_threads_thread_id_state_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLatestThreadStateThreadsThreadIdStateGetError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_thread_history_post_threads_thread_id_history_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetThreadHistoryPostThreadsThreadIdHistoryPostError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_thread_history_threads_thread_id_history_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetThreadHistoryThreadsThreadIdHistoryGetError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetThreadStateAtCheckpointThreadsThreadIdStateCheckpointIdGetError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_thread_threads_thread_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetThreadThreadsThreadIdGetError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`join_thread_stream_threads_thread_id_stream_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum JoinThreadStreamThreadsThreadIdStreamGetError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`patch_thread_threads_thread_id_patch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PatchThreadThreadsThreadIdPatchError {
    Status404(String),
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostThreadStateAtCheckpointThreadsThreadIdStateCheckpointIdGetError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_threads_threads_search_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchThreadsThreadsSearchPostError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_thread_state_threads_thread_id_state_post`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateThreadStateThreadsThreadIdStatePostError {
    Status422(String),
    UnknownValue(serde_json::Value),
}

/// Create a new thread with a copy of the state and checkpoints from an existing thread.
pub fn copy_thread_post_threads_thread_id_copy_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;

    let uri_str = format!(
        "{}/threads/{thread_id}/copy",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn copy_thread_post_threads_thread_id_copy_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
) -> Result<models::Thread, Error<CopyThreadPostThreadsThreadIdCopyPostError>> {
    let req_builder =
        copy_thread_post_threads_thread_id_copy_post_request_builder(configuration, thread_id)
            .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Thread`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Thread`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CopyThreadPostThreadsThreadIdCopyPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the count of threads matching the specified criteria.
pub fn count_threads_threads_count_post_request_builder(
    configuration: &configuration::Configuration,
    thread_count_request: models::ThreadCountRequest,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_thread_count_request = thread_count_request;

    let uri_str = format!("{}/threads/count", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_count_request);

    Ok(req_builder)
}

pub async fn count_threads_threads_count_post(
    configuration: &configuration::Configuration,
    thread_count_request: models::ThreadCountRequest,
) -> Result<i32, Error<CountThreadsThreadsCountPostError>> {
    let req_builder =
        count_threads_threads_count_post_request_builder(configuration, thread_count_request)
            .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `i32`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `i32`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CountThreadsThreadsCountPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a thread.
pub fn create_thread_threads_post_request_builder(
    configuration: &configuration::Configuration,
    thread_create: models::ThreadCreate,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_thread_create = thread_create;

    let uri_str = format!("{}/threads", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_create);

    Ok(req_builder)
}

pub async fn create_thread_threads_post(
    configuration: &configuration::Configuration,
    thread_create: models::ThreadCreate,
) -> Result<models::Thread, Error<CreateThreadThreadsPostError>> {
    let req_builder = create_thread_threads_post_request_builder(configuration, thread_create)
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Thread`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Thread`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateThreadThreadsPostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete a thread by ID.
pub fn delete_thread_threads_thread_id_delete_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;

    let uri_str = format!(
        "{}/threads/{thread_id}",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn delete_thread_threads_thread_id_delete(
    configuration: &configuration::Configuration,
    thread_id: &str,
) -> Result<serde_json::Value, Error<DeleteThreadThreadsThreadIdDeleteError>> {
    let req_builder =
        delete_thread_threads_thread_id_delete_request_builder(configuration, thread_id)
            .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `serde_json::Value`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteThreadThreadsThreadIdDeleteError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get state for a thread.  The latest state of the thread (i.e. latest checkpoint) is returned.
pub fn get_latest_thread_state_threads_thread_id_state_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    subgraphs: Option<bool>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_query_subgraphs = subgraphs;

    let uri_str = format!(
        "{}/threads/{thread_id}/state",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_subgraphs {
        req_builder = req_builder.query(&[("subgraphs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn get_latest_thread_state_threads_thread_id_state_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    subgraphs: Option<bool>,
) -> Result<models::ThreadState, Error<GetLatestThreadStateThreadsThreadIdStateGetError>> {
    let req_builder = get_latest_thread_state_threads_thread_id_state_get_request_builder(
        configuration,
        thread_id,
        subgraphs,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::ThreadState`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ThreadState`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLatestThreadStateThreadsThreadIdStateGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all past states for a thread.
pub fn get_thread_history_post_threads_thread_id_history_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_state_search: models::ThreadStateSearch,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_thread_state_search = thread_state_search;

    let uri_str = format!(
        "{}/threads/{thread_id}/history",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_state_search);

    Ok(req_builder)
}

pub async fn get_thread_history_post_threads_thread_id_history_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_state_search: models::ThreadStateSearch,
) -> Result<Vec<models::ThreadState>, Error<GetThreadHistoryPostThreadsThreadIdHistoryPostError>> {
    let req_builder = get_thread_history_post_threads_thread_id_history_post_request_builder(
        configuration,
        thread_id,
        thread_state_search,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ThreadState&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ThreadState&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetThreadHistoryPostThreadsThreadIdHistoryPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all past states for a thread.
pub fn get_thread_history_threads_thread_id_history_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    limit: Option<i32>,
    before: Option<&str>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_query_limit = limit;
    let p_query_before = before;

    let uri_str = format!(
        "{}/threads/{thread_id}/history",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_before {
        req_builder = req_builder.query(&[("before", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn get_thread_history_threads_thread_id_history_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    limit: Option<i32>,
    before: Option<&str>,
) -> Result<Vec<models::ThreadState>, Error<GetThreadHistoryThreadsThreadIdHistoryGetError>> {
    let req_builder = get_thread_history_threads_thread_id_history_get_request_builder(
        configuration,
        thread_id,
        limit,
        before,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ThreadState&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ThreadState&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetThreadHistoryThreadsThreadIdHistoryGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get state for a thread at a specific checkpoint.
pub fn get_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    checkpoint_id: &str,
    subgraphs: Option<bool>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_path_checkpoint_id = checkpoint_id;
    let p_query_subgraphs = subgraphs;

    let uri_str = format!(
        "{}/threads/{thread_id}/state/{checkpoint_id}",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id),
        checkpoint_id = crate::apis::urlencode(p_path_checkpoint_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_subgraphs {
        req_builder = req_builder.query(&[("subgraphs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn get_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    checkpoint_id: &str,
    subgraphs: Option<bool>,
) -> Result<
    models::ThreadState,
    Error<GetThreadStateAtCheckpointThreadsThreadIdStateCheckpointIdGetError>,
> {
    let req_builder =
        get_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get_request_builder(
            configuration,
            thread_id,
            checkpoint_id,
            subgraphs,
        )
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::ThreadState`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ThreadState`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetThreadStateAtCheckpointThreadsThreadIdStateCheckpointIdGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a thread by ID.
pub fn get_thread_threads_thread_id_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;

    let uri_str = format!(
        "{}/threads/{thread_id}",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    Ok(req_builder)
}

pub async fn get_thread_threads_thread_id_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
) -> Result<models::Thread, Error<GetThreadThreadsThreadIdGetError>> {
    let req_builder = get_thread_threads_thread_id_get_request_builder(configuration, thread_id)
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Thread`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Thread`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetThreadThreadsThreadIdGetError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// This endpoint streams output in real-time from a thread. The stream will include the output of each run executed sequentially on the thread and will remain open indefinitely. It is the responsibility of the calling client to close the connection.
pub fn join_thread_stream_threads_thread_id_stream_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    last_event_id: Option<&str>,
    stream_modes: Option<&str>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_header_last_event_id = last_event_id;
    let p_query_stream_modes = stream_modes;

    let uri_str = format!(
        "{}/threads/{thread_id}/stream",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_stream_modes {
        req_builder = req_builder.query(&[("stream_modes", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(param_value) = p_header_last_event_id {
        req_builder = req_builder.header("Last-Event-ID", param_value.to_string());
    }

    Ok(req_builder)
}

pub async fn join_thread_stream_threads_thread_id_stream_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    last_event_id: Option<&str>,
    stream_modes: Option<&str>,
) -> Result<String, Error<JoinThreadStreamThreadsThreadIdStreamGetError>> {
    let req_builder = join_thread_stream_threads_thread_id_stream_get_request_builder(
        configuration,
        thread_id,
        last_event_id,
        stream_modes,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `String`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `String`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<JoinThreadStreamThreadsThreadIdStreamGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a thread.
pub fn patch_thread_threads_thread_id_patch_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_patch: models::ThreadPatch,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_thread_patch = thread_patch;

    let uri_str = format!(
        "{}/threads/{thread_id}",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_patch);

    Ok(req_builder)
}

pub async fn patch_thread_threads_thread_id_patch(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_patch: models::ThreadPatch,
) -> Result<models::Thread, Error<PatchThreadThreadsThreadIdPatchError>> {
    let req_builder = patch_thread_threads_thread_id_patch_request_builder(
        configuration,
        thread_id,
        thread_patch,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::Thread`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Thread`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PatchThreadThreadsThreadIdPatchError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get state for a thread at a specific checkpoint.
pub fn post_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_state_checkpoint_request: models::ThreadStateCheckpointRequest,
    subgraphs: Option<bool>,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_thread_state_checkpoint_request = thread_state_checkpoint_request;
    let p_query_subgraphs = subgraphs;

    let uri_str = format!(
        "{}/threads/{thread_id}/state/checkpoint",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_subgraphs {
        req_builder = req_builder.query(&[("subgraphs", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_state_checkpoint_request);

    Ok(req_builder)
}

pub async fn post_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_state_checkpoint_request: models::ThreadStateCheckpointRequest,
    subgraphs: Option<bool>,
) -> Result<
    models::ThreadState,
    Error<PostThreadStateAtCheckpointThreadsThreadIdStateCheckpointIdGetError>,
> {
    let req_builder =
        post_thread_state_at_checkpoint_threads_thread_id_state_checkpoint_id_get_request_builder(
            configuration,
            thread_id,
            thread_state_checkpoint_request,
            subgraphs,
        )
        .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::ThreadState`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ThreadState`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostThreadStateAtCheckpointThreadsThreadIdStateCheckpointIdGetError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Search for threads.  This endpoint also functions as the endpoint to list all threads.
pub fn search_threads_threads_search_post_request_builder(
    configuration: &configuration::Configuration,
    thread_search_request: models::ThreadSearchRequest,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_thread_search_request = thread_search_request;

    let uri_str = format!("{}/threads/search", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_search_request);

    Ok(req_builder)
}

pub async fn search_threads_threads_search_post(
    configuration: &configuration::Configuration,
    thread_search_request: models::ThreadSearchRequest,
) -> Result<Vec<models::Thread>, Error<SearchThreadsThreadsSearchPostError>> {
    let req_builder =
        search_threads_threads_search_post_request_builder(configuration, thread_search_request)
            .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Thread&gt;`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Thread&gt;`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchThreadsThreadsSearchPostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add state to a thread.
pub fn update_thread_state_threads_thread_id_state_post_request_builder(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_state_update: models::ThreadStateUpdate,
) -> Result<reqwest::RequestBuilder, Error<serde_json::Error>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_thread_id = thread_id;
    let p_body_thread_state_update = thread_state_update;

    let uri_str = format!(
        "{}/threads/{thread_id}/state",
        configuration.base_path,
        thread_id = crate::apis::urlencode(p_path_thread_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.json(&p_body_thread_state_update);

    Ok(req_builder)
}

pub async fn update_thread_state_threads_thread_id_state_post(
    configuration: &configuration::Configuration,
    thread_id: &str,
    thread_state_update: models::ThreadStateUpdate,
) -> Result<models::ThreadStateUpdateResponse, Error<UpdateThreadStateThreadsThreadIdStatePostError>>
{
    let req_builder = update_thread_state_threads_thread_id_state_post_request_builder(
        configuration,
        thread_id,
        thread_state_update,
    )
    .map_err(super::map_request_builder_error)?;
    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => Err(Error::from(serde_json::Error::custom(
                "Received `text/plain` content type response that cannot be converted to `models::ThreadStateUpdateResponse`",
            ))),
            ContentType::Unsupported(unknown_type) => {
                Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ThreadStateUpdateResponse`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateThreadStateThreadsThreadIdStatePostError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
